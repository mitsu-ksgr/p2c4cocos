/***************************************************************************//**
 *  @file   {FileName}
 *  @brief  Implementation for the {ClassName} class.
 *
 *  @date   {GenerateTime}
 *  @autor  generated by {ScriptName} script.
 *          {ScriptName} written by Mitsu(https://github.com/mitsuaki-n).
 ******************************************************************************/
#include "{IncludeHeader}"

#include <string>
#include "cocos2d.h"

using namespace cocos2d;

bool {Namespace}{ClassName}::initWithTotalParticles(int number_of_particles)
{{
    if(!CCParticleSystemQuad::initWithTotalParticles({TotalParticles}))
        return false;

    //-------------------------------------------
    // Set Parameters.
    // Emitter name in particle designer 2.0
    this->_configName = "{ConfigName}";

    // Angle
    this->_angle    = {Angle}f;
    this->_angleVar = {AngleVariance}f;

    // Duration
    this->_duration = {Duration}f;

    // Blend Function
    this->_blendFunc.src = {BlendFuncSource};
    this->_blendFunc.dst = {BlendFuncDestination};

    // Color
    this->_startColor.r     = {StartColorRed}f;
    this->_startColor.g     = {StartColorGreen}f;
    this->_startColor.b     = {StartColorBlue}f;
    this->_startColor.a     = {StartColorAlpha}f;
    this->_startColorVar.r  = {StartColorVarianceRed}f;
    this->_startColorVar.g  = {StartColorVarianceGreen}f;
    this->_startColorVar.b  = {StartColorVarianceBlue}f;
    this->_startColorVar.a  = {StartColorVarianceAlpha}f;
    this->_endColor.r       = {FinishColorRed}f;
    this->_endColor.g       = {FinishColorGreen}f;
    this->_endColor.b       = {FinishColorBlue}f;
    this->_endColor.a       = {FinishColorAlpha}f;
    this->_endColorVar.r    = {FinishColorVarianceRed}f;
    this->_endColorVar.g    = {FinishColorVarianceGreen}f;
    this->_endColorVar.b    = {FinishColorVarianceBlue}f;
    this->_endColorVar.a    = {FinishColorVarianceAlpha}f;

    // Particle Size
    this->_startSize    = {StartParticleSize}f;
    this->_startSizeVar = {StartParticleSizeVariance}f;
    this->_endSize      = {FinishParticleSize}f;
    this->_endSizeVar   = {FinishParticleSizeVariance}f;

    // Position
    this->setPosition(Vec2({SourcePositionX}f, {SourcePositionY}f));
    this->_posVar.x = {SourcePositionVarianceX}f;
    this->_posVar.y = {SourcePositionVarianceY}f;

    // Spinning
    this->_startSpin    = {RotationStart}f;
    this->_startSpinVar = {RotationStartVariance}f;
    this->_endSpin      = {RotationEnd}f;
    this->_endSpinVar   = {RotationEndVariance}f;

    // Emitter Mode
    {EmitterConfigCodes}

    // Life Span
    this->_life     = {ParticleLifespan}f;
    this->_lifeVar  = {ParticleLifespanVariance}f;

    // Emission Rate
    this->_emissionRate = this->_totalParticles / this->_life;

    // Don't get the internal texture if a batchNode is used.
    if(this->_batchNode)
        return true;

    //-------------------------------------------
    // Load Texture.
    bool result = false;
    unsigned char *buffer = nullptr;
    unsigned char *deflated = nullptr;
    Image *image = nullptr;

    do {{
        // Set a compatible default for the alpha transfer.
        this->_opacityModifyRGB = false;

        // Texture: Try to get the texture from the cache.
        std::string dir_name = "{TextureDirectoryPath}";
        std::string tex_name = "{TextureFileName}";
        std::size_t r_pos = tex_name.rfind('/');

        if(r_pos != std::string::npos) {{
            std::string tex_dir = tex_name.substr(0, r_pos + 1);
            if(!dir_name.empty() && tex_dir != dir_name) {{
                tex_name = tex_name.substr(r_pos + 1);
                tex_name = dir_name + tex_name;
            }}
        }} else if(!dir_name.empty() && !tex_name.empty()) {{
            tex_name = dir_name + tex_name;
        }}

        Texture2D *tex = nullptr;
        if(tex_name.length() > 0) {{
            // Set not pop-up message box when load image failed.
            bool notify = FileUtils::getInstance()->isPopupNotify();
            FileUtils::getInstance()->setPopupNotify(false);
            tex = Director::getInstance()->getTextureCache()->addImage(tex_name);
            // reset the value of UIImage notify
            FileUtils::getInstance()->setPopupNotify(notify);
        }}

        if(tex) {{
            this->setTexture(tex);
        }} else {{
            std::string tex_data = "{TextureData}";
            CCASSERT(!tex_data.empty(), "{ClassName}: TextureData is empty!");

            std::size_t data_len = tex_data.size();
            CCASSERT(data_len != 0, "{ClassName}: TextureData is empty!");

            // if it fails, try to get it from the base64-gzipped data.
            int decode_len = base64Decode(
                reinterpret_cast<const unsigned char*>(tex_data.c_str()),
                static_cast<unsigned int>(data_len), &buffer);
            if(!buffer) break;

            ssize_t deflated_len =
                    ZipUtils::inflateMemory(buffer, decode_len, &deflated);
            if(!deflated) break;

            // For android, we should retain it in -
            // VolatileTexture::addImage which invoked in -
            // Director::getInstance()->getTextureCache()->addUIImage().
            image = new Image();
            if(!image) break;
            bool is_ok = image->initWithImageData(deflated, deflated_len);
            if(!is_ok) break;
            this->setTexture(
                Director::getInstance()->getTextureCache()->addImage(
                    image, tex_name.c_str()));
            image->release();
        }}

        this->_yCoordFlipped = {YCoordFlipped};
        if(!this->_texture)
            CCLOGWARN("cocos2d: Warning: {ClassName} without a texture");

        result = true;
    }} while(false);
    free(buffer);   buffer = nullptr;
    free(deflated); deflated = nullptr;
    CC_SAFE_DELETE(image);
    return result;
}}

